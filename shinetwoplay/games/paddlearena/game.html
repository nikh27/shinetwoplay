<!-- PaddleArena Game UI ‚Äî Multiplayer Pong -->
<style>
/* ===== PaddleArena Styles ===== */
.pa-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    max-width: 100vw;
    height: 100%;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none;
    overflow: hidden;
    position: relative;
    font-family: 'Inter', sans-serif;
}

/* Compact top row: exit + names/scores inline */
.pa-header {
    display: flex;
    align-items: center;
    width: 100%;
    padding: 6px 10px;
    box-sizing: border-box;
    flex-shrink: 0;
    gap: 8px;
    background: rgba(0,0,0,0.2);
}
.pa-exit-btn {
    width: 30px; height: 30px;
    border-radius: 50%;
    border: none;
    background: rgba(255,255,255,0.08);
    color: rgba(255,255,255,0.6);
    font-size: 14px;
    cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    flex-shrink: 0;
}
.pa-exit-btn:hover { background: rgba(255,255,255,0.15); color: #fff; }

/* Score strip ‚Äî fills remaining width */
.pa-score-strip {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
}
.pa-ps {
    display: flex;
    align-items: center;
    gap: 6px;
}
.pa-ps.right { flex-direction: row-reverse; }
.pa-av {
    width: 30px; height: 30px;
    border-radius: 50%;
    overflow: hidden;
    border: 2px solid;
    display: flex; align-items: center; justify-content: center;
    background: rgba(0,0,0,0.3);
    flex-shrink: 0;
}
.pa-av.c1 { border-color: #22d3ee; }
.pa-av.c2 { border-color: #f87171; }
.pa-av img { width: 100%; height: 100%; object-fit: cover; }
.pa-pinfo {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 0;
    min-width: 0;
}
.pa-ps.right .pa-pinfo { align-items: flex-end; }
.pa-pn {
    font-size: 11px;
    font-weight: 700;
    color: rgba(255,255,255,0.9);
    max-width: 70px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    line-height: 1.2;
}
.pa-pt {
    font-size: 8px;
    font-weight: 800;
    letter-spacing: 0.1em;
    line-height: 1;
}
.pa-pt.you { color: #34d399; }
.pa-pt.opp { color: #fbbf24; }

.pa-scores {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 0 4px;
}
.pa-sn {
    font-size: 28px;
    font-weight: 900;
    font-family: 'Inter', monospace;
    min-width: 24px;
    text-align: center;
}
.pa-sn.c1 { color: #22d3ee; text-shadow: 0 0 14px rgba(34,211,238,0.5); }
.pa-sn.c2 { color: #f87171; text-shadow: 0 0 14px rgba(248,113,113,0.5); }
.pa-sdash { color: #4b5563; font-weight: 700; font-size: 14px; }
.pa-round-badge {
    padding: 3px 8px;
    border-radius: 8px;
    background: rgba(255,255,255,0.06);
    color: rgba(255,255,255,0.4);
    font-size: 10px;
    font-weight: 600;
    letter-spacing: 0.08em;
    flex-shrink: 0;
}

/* Arena ‚Äî fills ALL remaining space */
.pa-arena-wrap {
    flex: 1;
    display: flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    padding: 0;
    box-sizing: border-box;
    min-height: 0;
    overflow: hidden;
}
.pa-arena {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: linear-gradient(180deg, #0c1929 0%, #0a0f1a 50%, #1a0f0f 100%);
}
/* Flip arena for P1 ‚Äî P1 is top paddle, but flipping 180 moves it to bottom visual */
.pa-arena.flipped { transform: rotate(180deg); }

/* Arena internals */
.pa-arena-inner {
    position: absolute;
    inset: 0;
}
.pa-lighting {
    position: absolute; inset: 0; pointer-events: none;
    background:
        radial-gradient(ellipse at 50% 0%, rgba(14,165,233,0.06) 0%, transparent 45%),
        radial-gradient(ellipse at 50% 100%, rgba(239,68,68,0.06) 0%, transparent 45%);
}
.pa-center-line {
    position: absolute; top: 50%; left: 8%; right: 8%; height: 2px;
    transform: translateY(-50%);
    border-radius: 99px;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
}
.pa-center-circle {
    position: absolute; top: 50%; left: 50%;
    width: 40px; height: 40px;
    transform: translate(-50%,-50%);
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.06);
}
.pa-goal-line {
    position: absolute; left: 20%; right: 20%; height: 4px; border-radius: 4px;
}
.pa-goal-top { top: 0; background: linear-gradient(180deg, rgba(14,165,233,0.3), transparent); }
.pa-goal-bottom { bottom: 0; background: linear-gradient(0deg, rgba(239,68,68,0.3), transparent); }

/* Paddles */
.pa-paddle {
    position: absolute;
    width: 25%;
    height: 12px;
    border-radius: 99px;
    z-index: 10;
}
.pa-paddle-glow {
    position: absolute; top: 2px; left: 10px; right: 10px; height: 4px;
    background: rgba(255,255,255,0.4);
    border-radius: 99px;
}
.pa-paddle-p1 {
    top: 5%;
    background: linear-gradient(180deg, #7dd3fc, #0ea5e9, #0284c7);
    box-shadow: 0 3px 0 #0369a1, 0 5px 16px rgba(14,165,233,0.5), inset 0 1px 3px rgba(255,255,255,0.4);
}
.pa-paddle-p2 {
    bottom: 5%;
    background: linear-gradient(180deg, #fca5a5, #ef4444, #dc2626);
    box-shadow: 0 3px 0 #b91c1c, 0 5px 16px rgba(239,68,68,0.5), inset 0 1px 3px rgba(255,255,255,0.4);
}

/* Balls */
.pa-ball {
    position: absolute;
    width: 16px; height: 16px;
    border-radius: 50%; z-index: 8;
    display: none;
}
.pa-ball-p1 {
    background: radial-gradient(circle at 30% 30%, #fff, #7dd3fc 40%, #0ea5e9 70%, #0369a1);
    box-shadow: 0 0 16px rgba(14,165,233,0.7), 0 0 30px rgba(14,165,233,0.3);
}
.pa-ball-p2 {
    background: radial-gradient(circle at 30% 30%, #fff, #fca5a5 40%, #ef4444 70%, #b91c1c);
    box-shadow: 0 0 16px rgba(239,68,68,0.7), 0 0 30px rgba(239,68,68,0.3);
}

/* Trail */
.pa-trail {
    position: absolute; border-radius: 50%; pointer-events: none;
    animation: pa-trail-fade 0.2s ease-out forwards;
}
@keyframes pa-trail-fade { 0%{opacity:.4;transform:scale(1)} 100%{opacity:0;transform:scale(.15)} }

/* Hit ring */
.pa-ring {
    position: absolute; border-radius: 50%; pointer-events: none;
    animation: pa-ring-expand 0.3s ease-out forwards;
}
@keyframes pa-ring-expand { 0%{transform:translate(-50%,-50%) scale(.4);opacity:1} 100%{transform:translate(-50%,-50%) scale(2.2);opacity:0} }

/* Obstacles */
.pa-obs {
    position: absolute; border-radius: 5px; z-index: 5;
    transition: opacity 0.2s;
}
.pa-obs-perm {
    background: linear-gradient(180deg, #c4b5fd, #8b5cf6, #7c3aed);
    box-shadow: 0 2px 0 #5b21b6, 0 4px 12px rgba(139,92,246,0.4), inset 0 1px 2px rgba(255,255,255,0.35);
}
.pa-obs-temp {
    background: linear-gradient(180deg, #fda4af, #fb7185, #f43f5e);
    box-shadow: 0 2px 0 #be123c, 0 3px 8px rgba(251,113,133,0.3), inset 0 1px 2px rgba(255,255,255,0.25);
}
.pa-obs-shake { animation: pa-obs-shake 0.12s ease-out; }
@keyframes pa-obs-shake { 0%,100%{transform:translateX(0)} 33%{transform:translateX(-2px)} 66%{transform:translateX(2px)} }

/* Overlays */
.pa-overlay {
    position: absolute; inset: 0;
    background: rgba(0,0,0,0.85);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    z-index: 50;
    padding: 20px;
    text-align: center;
}
.pa-overlay.hidden { display: none; }
/* Counter-rotate overlays so text is readable on flipped arena */
.pa-arena.flipped .pa-overlay { transform: rotate(180deg); }

.pa-overlay-emoji { font-size: 40px; margin-bottom: 8px; animation: pa-bob 2.5s ease-in-out infinite; }
@keyframes pa-bob { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-5px)} }
.pa-overlay-title { font-size: 20px; font-weight: 900; color: #fff; letter-spacing: 0.1em; }
.pa-overlay-sub { font-size: 12px; color: #9ca3af; letter-spacing: 0.1em; margin-top: 4px; margin-bottom: 12px; }
.pa-role-tag {
    padding: 4px 12px; border-radius: 14px; font-size: 11px; font-weight: 700; letter-spacing: 0.08em;
}
.pa-role-tag.p1 { background: rgba(14,165,233,0.15); color: #22d3ee; border: 1px solid rgba(14,165,233,0.25); }
.pa-role-tag.p2 { background: rgba(239,68,68,0.15); color: #f87171; border: 1px solid rgba(239,68,68,0.25); }
.pa-msg { font-size: 16px; font-weight: 700; color: #fff; margin-top: 10px; }
.pa-waiting {
    font-size: 11px; color: #6b7280; margin-top: 12px;
    animation: pa-pulse 1.4s ease-in-out infinite;
}
@keyframes pa-pulse { 0%,100%{opacity:.4} 50%{opacity:1} }

/* Game Over / Round Over */
.pa-result-text { font-size: 24px; font-weight: 900; text-shadow: 0 0 25px currentColor; margin-bottom: 8px; }
.pa-final-row { display: flex; gap: 30px; margin-bottom: 15px; align-items: flex-end; }
.pa-final-block { display: flex; flex-direction: column; align-items: center; gap: 4px; }
.pa-final-circle {
    width: 48px; height: 48px; border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-size: 20px; font-weight: 900; color: #fff;
}
.pa-final-circle.p1 { background: linear-gradient(180deg,#22d3ee,#0891b2); box-shadow: 0 3px 0 #0e7490; }
.pa-final-circle.p2 { background: linear-gradient(180deg,#f87171,#dc2626); box-shadow: 0 3px 0 #b91c1c; }
.pa-next-round {
    font-size: 11px; color: #9ca3af; margin-top: 8px;
    animation: pa-pulse 1s ease-in-out infinite;
}

/* Score pop */
@keyframes pa-pop { 0%{transform:scale(1)} 50%{transform:scale(1.2)} 100%{transform:scale(1)} }
.pa-pop { animation: pa-pop 0.25s ease-out; }
</style>

<div class="pa-wrapper">
    <!-- Compact header -->
    <div class="pa-header">
        <button class="pa-exit-btn" onclick="exitGame()" title="Exit">‚úï</button>
        <div class="pa-score-strip">
            <div class="pa-ps" id="pa-ps1">
                <div class="pa-av c1" id="pa-av1"></div>
                <div class="pa-pinfo">
                    <div class="pa-pn" id="pa-pn1">P1</div>
                    <div class="pa-pt" id="pa-pt1"></div>
                </div>
            </div>
            <div class="pa-scores">
                <div class="pa-sn c1" id="pa-s1">0</div>
                <div class="pa-sdash">‚Äì</div>
                <div class="pa-sn c2" id="pa-s2">0</div>
            </div>
            <div class="pa-ps right" id="pa-ps2">
                <div class="pa-av c2" id="pa-av2"></div>
                <div class="pa-pinfo">
                    <div class="pa-pn" id="pa-pn2">P2</div>
                    <div class="pa-pt" id="pa-pt2"></div>
                </div>
            </div>
        </div>
        <div class="pa-round-badge" id="pa-round"></div>
    </div>

    <!-- Arena -->
    <div class="pa-arena-wrap">
        <div class="pa-arena" id="pa-arena">
            <div class="pa-arena-inner" id="pa-arena-inner">
                <div class="pa-lighting"></div>
                <div class="pa-center-line"></div>
                <div class="pa-center-circle"></div>
                <div class="pa-goal-line pa-goal-top"></div>
                <div class="pa-goal-line pa-goal-bottom"></div>

                <div id="pa-paddle1" class="pa-paddle pa-paddle-p1"><div class="pa-paddle-glow"></div></div>
                <div id="pa-paddle2" class="pa-paddle pa-paddle-p2"><div class="pa-paddle-glow"></div></div>

                <div id="pa-ball1" class="pa-ball pa-ball-p1"></div>
                <div id="pa-ball2" class="pa-ball pa-ball-p2"></div>

                <div id="pa-obs-layer"></div>
                <div id="pa-fx-layer" style="pointer-events:none;position:absolute;inset:0;z-index:12;"></div>

                <!-- Menu -->
                <div class="pa-overlay" id="pa-menu">
                    <div class="pa-overlay-emoji">üèì</div>
                    <div class="pa-overlay-title">PADDLE ARENA</div>
                    <div class="pa-overlay-sub" id="pa-role-text"></div>
                    <div class="pa-waiting" id="pa-wait-text">Starting game...</div>
                </div>

                <!-- Game/Serve Message -->
                <div class="pa-overlay hidden" id="pa-msg-ov" style="background:rgba(0,0,0,0.6)">
                    <div class="pa-msg" id="pa-msg-text"></div>
                </div>

                <!-- Game Result -->
                <div class="pa-overlay hidden" id="pa-gameover">
                    <div class="pa-overlay-emoji" id="pa-go-emoji">üèÜ</div>
                    <div class="pa-result-text" id="pa-go-text">WINNER!</div>
                    <div class="pa-final-row">
                        <div class="pa-final-block">
                            <div class="pa-final-circle p1" id="pa-go-s1">0</div>
                            <div class="pa-final-label" style="color:#22d3ee;font-size:10px;font-weight:700">P1</div>
                        </div>
                        <div class="pa-final-block">
                            <div class="pa-final-circle p2" id="pa-go-s2">0</div>
                            <div class="pa-final-label" style="color:#f87171;font-size:10px;font-weight:700">P2</div>
                        </div>
                    </div>
                    <div class="pa-next-round" id="pa-next-text"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
(function() {
    /* ========== CONSTANTS ========== */
    const PADDLE_W = 25;       /* % width */
    const BALL_R   = 2.5;      /* % width */
    const BALL_SPD = 0.55;     /* % per frame */
    const P1_Y     = 5;        /* P1 top % */
    const P2_Y     = 95;       /* P2 bottom % */
    const SERVE_DELAY = 1500;  /* ms between serves */

    class PaddleArenaGame extends BaseGame {
        constructor() {
            super();
            this.gameMode = 'real_time';
            this.myRole = null;
            this.playing = false;
            this.score = { p1: 0, p2: 0 };
            this.totalRounds = 1;
            
            this.p1X = (100 - PADDLE_W) / 2;
            this.p2X = (100 - PADDLE_W) / 2;
            
            this.ball1 = null; this.ball2 = null;
            this.obstacles = [];
            
            this._dragging = false; this._dragOff = 0;
            this._lastFrame = null; this._lastTrail = 0;
            
            /* Timers */
            this._raf = null;
            this._inputTimer = null;
            this._syncTimer = null;
            this._serveTimer = null;

            /* DOM */
            this.arena = document.getElementById('pa-arena');
            this.paddle1El = document.getElementById('pa-paddle1');
            this.paddle2El = document.getElementById('pa-paddle2');
            this.ball1El = document.getElementById('pa-ball1');
            this.ball2El = document.getElementById('pa-ball2');
            this.obsLayer = document.getElementById('pa-obs-layer');
            this.fxLayer = document.getElementById('pa-fx-layer');
            this.menuOv = document.getElementById('pa-menu');
            this.msgOv = document.getElementById('pa-msg-ov');
            this.goOv = document.getElementById('pa-gameover');
            this.s1El = document.getElementById('pa-s1');
            this.s2El = document.getElementById('pa-s2');
        }

        /* ===== INIT ===== */
        init(state) {
            this.state = state;
            const gp = state.players;
            this.myRole = (gp['P1'] === USER) ? 'P1' : 'P2';
            this.totalRounds = state.total_rounds || 1;
            
            /* Round display */
            this._updateRoundBadge();

            /* Scoreboard */
            this._setupScoreboard(gp);

            /* 
               P1's paddle is conceptually at the TOP (y=5%).
               We flip P1's arena 180¬∞ so the TOP appears at the BOTTOM.
               P2's paddle is conceptually at the BOTTOM (y=95%).
               We DON'T flip P2, so the BOTTOM appears at the BOTTOM.
               => Both players control their paddle at the bottom of the screen.
            */
            if (this.myRole === 'P1') this.arena.classList.add('flipped');

            const rt = document.getElementById('pa-role-text');
            rt.innerHTML = `<span class="pa-role-tag ${this.myRole==='P1'?'p1':'p2'}">You are ${this.myRole==='P1'?'Player 1':'Player 2'}</span>`;

            this._bindControls();
            setTimeout(() => this._startMatch(), 2000);
        }

        _setupScoreboard(gp) {
            /* Fallback if players var is missing */
            const roomP = (typeof players !== 'undefined') ? players : {};
            
            for (const role of ['P1', 'P2']) {
                const uname = gp[role];
                const n = role==='P1'?'1':'2';
                
                document.getElementById('pa-pn'+n).textContent = uname || role;
                                
                /* Avatar */
                const avEl = document.getElementById('pa-av'+n);
                const pd = roomP[uname];
                
                if (pd && pd.gender === 'female') {
                    avEl.innerHTML = `<img src="/static/games/icons/avatar_female.png" alt="">`;
                } else if (pd && pd.gender) {
                    avEl.innerHTML = `<img src="/static/games/icons/avatar_male.png" alt="">`;
                } else {
                    avEl.innerHTML = `<span style="font-size:14px">üë§</span>`;
                }

                const tag = document.getElementById('pa-pt'+n);
                if (uname === USER) { tag.textContent = 'YOU'; tag.className = 'pa-pt you'; }
                else { tag.textContent = 'OPP'; tag.className = 'pa-pt opp'; }
            }
        }

        /* ===== CONTROLS ===== */
        _bindControls() {
            this.arena.addEventListener('touchstart', e => this._tStart(e), { passive: false });
            this.arena.addEventListener('touchmove',  e => this._tMove(e), { passive: false });
            this.arena.addEventListener('touchend',   () => this._dragging=false, { passive:true });
            this.arena.addEventListener('mousedown', e => this._mDown(e));
            window.addEventListener('mousemove', e => this._mMove(e));
            window.addEventListener('mouseup', () => this._dragging=false);
        }

        _pctX(clientX) {
            const r = this.arena.getBoundingClientRect();
            let pct = ((clientX - r.left) / r.width) * 100;
            if (this.myRole === 'P1') pct = 100 - pct; /* Invert for flipped arena */
            return pct;
        }
        _myPX() { return this.myRole==='P1' ? this.p1X : this.p2X; }
        _setMyP(v) {
            v = Math.max(0, Math.min(100 - PADDLE_W, v));
            if (this.myRole==='P1') this.p1X = v; else this.p2X = v;
        }

        _tStart(e) { if(!this.playing)return; e.preventDefault(); const x=this._pctX(e.changedTouches[0].clientX); this._dragging=true; this._dragOff=x-this._myPX(); }
        _tMove(e) { if(!this._dragging||!this.playing)return; e.preventDefault(); this._setMyP(this._pctX(e.changedTouches[0].clientX)-this._dragOff); }
        _mDown(e)  { if(!this.playing)return; const x=this._pctX(e.clientX); this._dragging=true; this._dragOff=x-this._myPX(); }
        _mMove(e)  { if(!this._dragging||!this.playing)return; this._setMyP(this._pctX(e.clientX)-this._dragOff); }

        /* ===== MATCH FLOW ===== */
        _startMatch() {
            this.playing = true;
            this.score = { p1: 0, p2: 0 };
            this._showScore();
            this._updateRoundBadge();
            this.menuOv.classList.add('hidden');
            this.goOv.classList.add('hidden');
            
            /* Start networking */
            if (this._inputTimer) clearInterval(this._inputTimer);
            this._inputTimer = setInterval(() => this._sendPad(), 1000 / 15);
            
            if (this.myRole === 'P1') {
                if (this._syncTimer) clearInterval(this._syncTimer);
                this._syncTimer = setInterval(() => this._sendSync(), 1000 / 12);
                this._serve();
            }
            
            this._loop(performance.now());
        }

        _serve() {
            /* Create new balls and obstacles */
            this.ball1 = this._mkBall(true);
            this.ball2 = this._mkBall(false);
            this._mkObs();
            
            /* Send state to P2 */
            this.sendInput({ type: 'serve', b1: this.ball1, b2: this.ball2, obs: this.obstacles, sc: this.score });
            
            this.ball1El.style.display = 'block';
            this.ball2El.style.display = 'block';
            this.msgOv.classList.add('hidden');
        }

        /* ===== LOGIC ===== */
        _mkBall(isTop) {
            const a = Math.PI/5 + Math.random() * Math.PI/5;
            const dx = Math.random() > 0.5 ? 1 : -1;
            return { x: 50, y: isTop ? 16 : 84, vx: Math.cos(a)*BALL_SPD*dx, vy: isTop ? BALL_SPD : -BALL_SPD, active: true };
        }
        _mkObs() {
            this.obstacles = [];
            this.obsLayer.innerHTML = '';
            for(let i=0; i<2; i++) {
                const o={id:'op'+i, x:i===0?10+Math.random()*15:60+Math.random()*15, y:46+Math.random()*8, w:14, h:4, perm:true, hp:999};
                this.obstacles.push(o); this._addObs(o);
            }
            for(let i=0; i<3; i++) {
                const o={id:'ot'+i, x:14+Math.random()*56, y:36+Math.random()*28, w:12, h:3.5, perm:false, hp:2};
                this.obstacles.push(o); this._addObs(o);
            }
        }
        _addObs(o) {
            const el = document.createElement('div'); el.id=o.id;
            el.className = 'pa-obs ' + (o.perm?'pa-obs-perm':'pa-obs-temp');
            el.style.cssText = `left:${o.x}%;top:${o.y}%;width:${o.w}%;height:${o.h}%;`;
            this.obsLayer.appendChild(el);
        }
        _loadObs(obs) {
            this.obstacles = obs; this.obsLayer.innerHTML='';
            obs.forEach(o => this._addObs(o));
        }

        /* ===== NETWORKING ===== */
        _sendPad() { this.sendInput({ type: 'p', r: this.myRole, x: this._myPX() }); }
        _sendSync() {
            if (this.myRole !== 'P1' || !this.ball1 || !this.ball2) return;
            this.sendInput({ type: 's', b1: this.ball1, b2: this.ball2, sc: this.score, obs: this.obstacles.map(o=>({id:o.id, hp:o.hp})) });
        }

        onRemoteInput(player, d) {
            if (player === USER) return;
            
            if (d.type === 'p') {
                if(d.r==='P1') this.p1X=d.x; else this.p2X=d.x;
            } 
            else if (d.type === 's' && this.myRole === 'P2') {
                /* Sync state from P1 */
                if(this.ball1) Object.assign(this.ball1, d.b1); else this.ball1 = d.b1;
                if(this.ball2) Object.assign(this.ball2, d.b2); else this.ball2 = d.b2;
                
                if (d.sc) { this.score = d.sc; this._showScore(); }
                if (d.obs) this._syncObs(d.obs);
                
                const b1a = this.ball1 && this.ball1.active;
                const b2a = this.ball2 && this.ball2.active;
                this.ball1El.style.display = b1a ? 'block': 'none';
                this.ball2El.style.display = b2a ? 'block': 'none';
            } 
            else if (d.type === 'serve' && this.myRole === 'P2') {
                this.ball1 = d.b1; this.ball2 = d.b2;
                this.score = d.sc; this._showScore();
                this._loadObs(d.obs);
                this.ball1El.style.display = 'block';
                this.ball2El.style.display = 'block';
                this.msgOv.classList.add('hidden');
            }
            else if (d.type === 'over') {
                this._onGameOver(d.winner, d.sc);
            }
        }
        
        _syncObs(remoteObs) {
            for (const rod of remoteObs) {
                const o = this.obstacles.find(x => x.id === rod.id);
                if (!o) continue;
                o.hp = rod.hp;
                const el = document.getElementById(o.id);
                if (el) {
                    if (o.hp <= 0) el.style.display = 'none';
                    else if (!o.perm && o.hp < 2) el.style.opacity = '0.5';
                }
            }
        }

        /* ===== PHYSICS (P1) ===== */
        _phys(b, dt) {
            if (!b || !b.active) return b;
            let { x, y, vx, vy } = b;
            x += vx*dt; y += vy*dt;
            const br = BALL_R;

            /* Walls */
            if (x<=br) { vx=Math.abs(vx); x=br; this._hitFx(x,y,'#fff'); }
            if (x>=100-br) { vx=-Math.abs(vx); x=100-br; this._hitFx(x,y,'#fff'); }

            /* Paddle 1 (Top) */
            if (vy<0 && y-br <= P1_Y+2.5 && y > P1_Y) {
                if (x >= this.p1X-2 && x <= this.p1X+PADDLE_W+2) {
                    vx = ((x-this.p1X)/PADDLE_W - 0.5)*BALL_SPD*2.2;
                    vy = Math.abs(vy); y = P1_Y+2.5+br; this._hitFx(x,y,'#0ea5e9');
                }
            }
            /* Paddle 2 (Bottom) */
            if (vy>0 && y+br >= P2_Y-2.5 && y < P2_Y) {
                if (x >= this.p2X-2 && x <= this.p2X+PADDLE_W+2) {
                    vx = ((x-this.p2X)/PADDLE_W - 0.5)*BALL_SPD*2.2;
                    vy = -Math.abs(vy); y = P2_Y-2.5-br; this._hitFx(x,y,'#ef4444');
                }
            }

            /* Obstacles */
            for (const o of this.obstacles) {
                if (o.hp > 0 && x+br > o.x && x-br < o.x+o.w && y+br > o.y && y-br < o.y+o.h) {
                    const ol=x+br-o.x, or=o.x+o.w-(x-br), ot=y+br-o.y, ob=o.y+o.h-(y-br);
                    if (Math.min(ol,or) < Math.min(ot,ob)) vx=-vx; else vy=-vy;
                    this._hitFx(x,y,o.perm?'#8b5cf6':'#fb7185');
                    if(!o.perm) { o.hp--; if(o.hp<=0) document.getElementById(o.id).style.display='none'; }
                    break;
                }
            }

            /* Normalize */
            const s = Math.sqrt(vx*vx+vy*vy);
            if (s>0.01) { vx=(vx/s)*BALL_SPD; vy=(vy/s)*BALL_SPD; }

            /* Score ‚Äî any ball miss = instant point */
            if (y < -4) { this._pointScored('p2'); return {...b, active:false}; }
            if (y > 104) { this._pointScored('p1'); return {...b, active:false}; }
            
            return { x, y, vx, vy, active: true };
        }

        _loop(ts) {
            if (!this.playing) return;
            if (!this._lastFrame) this._lastFrame = ts;
            const dt = Math.min(2.5, (ts - this._lastFrame)/16.667);
            this._lastFrame = ts;

            this.paddle1El.style.left = this.p1X + '%';
            this.paddle2El.style.left = this.p2X + '%';

            if (this.myRole === 'P1') {
                /* Physics */
                if(this.ball1 && this.ball1.active) this.ball1 = this._phys(this.ball1, dt);
                if(this.ball2 && this.ball2.active) this.ball2 = this._phys(this.ball2, dt);
                
                this._rBall(this.ball1, this.ball1El, true, ts);
                this._rBall(this.ball2, this.ball2El, false, ts);
            } else {
                /* P2 render */
                this._rBall(this.ball1, this.ball1El, true, ts);
                this._rBall(this.ball2, this.ball2El, false, ts);
            }
            
            /* Keep loop running until gameover */
            if (this.playing) this._raf = requestAnimationFrame(t => this._loop(t));
        }

        /* Any ball miss = 1 round done, +1 point to scorer */
        _pointScored(who) {
            if (this._serveTimer) return; /* Already handling */
            this.score[who]++;
            this._showScore();
            
            /* Kill both balls immediately */
            if (this.ball1) this.ball1.active = false;
            if (this.ball2) this.ball2.active = false;
            this.ball1El.style.display = 'none';
            this.ball2El.style.display = 'none';
            
            const roundsPlayed = this.score.p1 + this.score.p2;
            this._updateRoundBadge();
            
            /* All rounds done? */
            if (roundsPlayed >= this.totalRounds) {
                this._endGame();
            } else {
                /* Re-serve after short delay */
                this._serveTimer = setTimeout(() => {
                    this._serveTimer = null;
                    this._serve();
                }, SERVE_DELAY);
            }
        }
        
        _updateRoundBadge() {
            const played = this.score.p1 + this.score.p2;
            const badge = document.getElementById('pa-round');
            badge.textContent = `R${played + 1}/${this.totalRounds}`;
        }
        
        _endGame() {
            this.playing = false;
            if(this._inputTimer) clearInterval(this._inputTimer);
            if(this._syncTimer) clearInterval(this._syncTimer);
            
            let w = 'draw';
            if (this.score.p1 > this.score.p2) w = 'P1';
            else if (this.score.p2 > this.score.p1) w = 'P2';
            
            this.sendMove('round_end', { winner: w, p1_score: this.score.p1, p2_score: this.score.p2 });
            this.sendInput({ type: 'over', winner: w, sc: this.score });
            this._onGameOver(w, this.score);
        }

        _onGameOver(w, sc) {
            this.playing = false;
            const t = document.getElementById('pa-go-text');
            const e = document.getElementById('pa-go-emoji');
            
            let wName = this.state.players[w];
            if (w === 'draw') {
                t.textContent = "DRAW!"; e.textContent = 'ü§ù';
            } else {
                if (wName === USER) { t.textContent = "YOU WIN! üéâ"; e.textContent = 'üèÜ'; }
                else { t.textContent = `${wName} WINS!`; e.textContent = 'üòî'; }
                t.style.color = w==='P1'?'#22d3ee':'#f87171';
            }
            
            document.getElementById('pa-go-s1').textContent = sc.p1;
            document.getElementById('pa-go-s2').textContent = sc.p2;
            document.getElementById('pa-next-text').textContent = 'Next round soon...';
            this.goOv.classList.remove('hidden');
        }

        _rBall(b, el, isP1, ts) {
            if (!b || !b.active) { el.style.display='none'; return; }
            el.style.display='block';
            el.style.left = `calc(${b.x}% - 8px)`;
            el.style.top = `calc(${b.y}% - 8px)`;
            if(ts-this._lastTrail>40) { this._trail(b.x,b.y,isP1); this._lastTrail=ts; }
        }
        _showScore() {
            this.s1El.textContent = this.score.p1; this.s2El.textContent = this.score.p2;
            this.s1El.classList.remove('pa-pop'); this.s2El.classList.remove('pa-pop');
            void this.s1El.offsetWidth; this.s1El.classList.add('pa-pop'); this.s2El.classList.add('pa-pop');
        }
        _trail(x,y,isP1) {
            const t=document.createElement('div'); t.className='pa-trail';
            t.style.cssText=`left:${x}%;top:${y}%;background:${isP1?'rgba(14,165,233,0.4)':'rgba(239,68,68,0.4)'}`;
            this.fxLayer.appendChild(t); setTimeout(()=>t.remove(),200);
        }
        _hitFx(x,y,c) {
            const r=document.createElement('div'); r.className='pa-ring';
            r.style.cssText=`left:${x}%;top:${y}%;border:2px solid ${c};box-shadow:0 0 10px ${c}`;
            this.fxLayer.appendChild(r); setTimeout(()=>r.remove(),300);
        }
        
        update(state) { this.state=state; }
        onRoundEnd(result) {
            /* Server acknowledged round end ‚Äî restart match after 3s */
            if (result && result.game_ended) {
                /* All rounds done ‚Äî show final result, no restart */
                document.getElementById('pa-next-text').textContent = 'Game Over';
                return;
            }
            /* More rounds to play ‚Äî auto-restart */
            setTimeout(() => {
                this.score = { p1: 0, p2: 0 };
                this._showScore();
                this.goOv.classList.add('hidden');
                this._startMatch();
            }, 3000);
        }
        onGameEnd(result) {
            this.playing = false;
            document.getElementById('pa-next-text').textContent = 'Game Over';
        }
        destroy() {
            this.playing = false;
            if(this._inputTimer) clearInterval(this._inputTimer);
            if(this._syncTimer) clearInterval(this._syncTimer);
            if(this._serveTimer) clearTimeout(this._serveTimer);
            if(this._raf) cancelAnimationFrame(this._raf);
            super.destroy();
        }
    }
    window.GameClasses = window.GameClasses || {};
    window.GameClasses['paddlearena'] = PaddleArenaGame;
})();

// Exit game ‚Äî sends WebSocket event to return both players to lobby
window.exitGame = function() {
    if (confirm('Leave the game? Both players will return to lobby.')) {
        if (typeof socket !== 'undefined' && socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({ event: 'game_exit' }));
        }
    }
};
</script>
