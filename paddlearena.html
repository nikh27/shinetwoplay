<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Paddle Arena - 2 Player</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      overflow: hidden;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    /* 3D Arena */
    .arena {
      transform-style: preserve-3d;
      transform: perspective(1000px) rotateX(3deg);
      box-shadow: 
        0 30px 60px rgba(0,0,0,0.8),
        inset 0 0 100px rgba(0,0,0,0.5),
        inset 0 2px 0 rgba(255,255,255,0.05);
    }

    /* Paddle 3D Effect */
    .paddle {
      transform: translateZ(15px);
      transition: left 0.03s linear;
    }
    
    .paddle-p1 {
      background: linear-gradient(180deg, #7dd3fc 0%, #0ea5e9 40%, #0284c7 100%);
      box-shadow: 
        0 6px 0 #0369a1,
        0 8px 25px rgba(14, 165, 233, 0.6),
        inset 0 3px 6px rgba(255,255,255,0.5),
        inset 0 -2px 4px rgba(0,0,0,0.2);
    }
    
    .paddle-p2 {
      background: linear-gradient(180deg, #fca5a5 0%, #ef4444 40%, #dc2626 100%);
      box-shadow: 
        0 6px 0 #b91c1c,
        0 8px 25px rgba(239, 68, 68, 0.6),
        inset 0 3px 6px rgba(255,255,255,0.5),
        inset 0 -2px 4px rgba(0,0,0,0.2);
    }

    /* Ball with glow */
    .ball {
      transform: translateZ(20px);
    }
    
    .ball-p1 {
      background: radial-gradient(circle at 30% 30%, #ffffff 0%, #7dd3fc 35%, #0ea5e9 70%, #0369a1 100%);
      box-shadow: 
        0 4px 8px rgba(0,0,0,0.4),
        0 0 25px rgba(14, 165, 233, 0.8),
        0 0 50px rgba(14, 165, 233, 0.4);
    }
    
    .ball-p2 {
      background: radial-gradient(circle at 30% 30%, #ffffff 0%, #fca5a5 35%, #ef4444 70%, #b91c1c 100%);
      box-shadow: 
        0 4px 8px rgba(0,0,0,0.4),
        0 0 25px rgba(239, 68, 68, 0.8),
        0 0 50px rgba(239, 68, 68, 0.4);
    }

    /* Ball Trail */
    .ball-trail {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      animation: trail-fade 0.3s ease-out forwards;
    }
    
    @keyframes trail-fade {
      0% { transform: scale(1); opacity: 0.6; }
      100% { transform: scale(0.3); opacity: 0; }
    }

    /* Hit Effect */
    .hit-effect {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      animation: hit-expand 0.4s ease-out forwards;
    }
    
    @keyframes hit-expand {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
    }

    /* Spark particles */
    .spark {
      position: absolute;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      pointer-events: none;
      animation: spark-fly 0.5s ease-out forwards;
    }
    
    @keyframes spark-fly {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }

    /* Obstacle 3D */
    .obstacle {
      transform: translateZ(10px);
      transition: opacity 0.2s, transform 0.1s;
    }
    
    .obstacle-permanent {
      background: linear-gradient(180deg, #c4b5fd 0%, #8b5cf6 50%, #7c3aed 100%);
      box-shadow: 
        0 5px 0 #5b21b6,
        0 8px 20px rgba(139, 92, 246, 0.5),
        inset 0 2px 4px rgba(255,255,255,0.4);
    }
    
    .obstacle-temp {
      background: linear-gradient(180deg, #fda4af 0%, #fb7185 50%, #f43f5e 100%);
      box-shadow: 
        0 4px 0 #be123c,
        0 6px 15px rgba(251, 113, 133, 0.4),
        inset 0 2px 4px rgba(255,255,255,0.3);
    }
    
    .obstacle-hit {
      animation: obstacle-shake 0.15s ease-out;
    }
    
    @keyframes obstacle-shake {
      0%, 100% { transform: translateZ(10px) translateX(0); }
      25% { transform: translateZ(10px) translateX(-3px); }
      75% { transform: translateZ(10px) translateX(3px); }
    }

    /* Floating animation */
    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-8px); }
    }

    /* Pulse glow */
    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 20px currentColor; }
      50% { box-shadow: 0 0 40px currentColor, 0 0 60px currentColor; }
    }

    /* Button press */
    .btn-3d {
      transition: transform 0.1s, box-shadow 0.1s;
    }
    
    .btn-3d:active {
      transform: translateY(3px);
      box-shadow: 0 2px 0 #15803d, 0 4px 15px rgba(34,197,94,0.3) !important;
    }

    /* Score pulse */
    @keyframes score-pop {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }
    
    .score-pop {
      animation: score-pop 0.3s ease-out;
    }
  </style>
</head>
<body class="bg-gray-950 min-h-screen flex items-center justify-center overflow-hidden">
  
  <div id="gameShell" class="relative" style="perspective: 1000px; transform-origin: center;">
    <!-- Arcade Cabinet Frame -->
    <div class="bg-gradient-to-b from-gray-800 to-gray-900 p-3 rounded-3xl shadow-2xl" 
         style="box-shadow: 0 30px 60px rgba(0,0,0,0.7), inset 0 1px 0 rgba(255,255,255,0.1);">
      
      <!-- Score Panel -->
      <div class="flex justify-between items-center px-6 py-3 mb-3 bg-black/60 rounded-xl"
           style="box-shadow: inset 0 2px 10px rgba(0,0,0,0.8);">
        <div class="text-center">
          <div id="score1" class="text-3xl font-black text-cyan-400" style="text-shadow: 0 0 20px #22d3ee;">0</div>
          <div class="text-xs text-cyan-600 font-semibold tracking-wider">PLAYER 1</div>
        </div>
        <div class="text-gray-600 font-bold text-lg">VS</div>
        <div class="text-center">
          <div id="score2" class="text-3xl font-black text-red-400" style="text-shadow: 0 0 20px #f87171;">0</div>
          <div class="text-xs text-red-600 font-semibold tracking-wider">PLAYER 2</div>
        </div>
      </div>

      <!-- Game Arena -->
      <div id="arena" class="arena relative overflow-hidden rounded-2xl"
           style="width: 340px; height: 600px; background: linear-gradient(180deg, #0c1929 0%, #0a0f1a 50%, #1a0f0f 100%); border: 4px solid #1e293b;">
        
        <!-- Arena Lighting Effects -->
        <div class="absolute inset-0 pointer-events-none"
             style="background: radial-gradient(ellipse at 50% 0%, rgba(14,165,233,0.1) 0%, transparent 50%), 
                    radial-gradient(ellipse at 50% 100%, rgba(239,68,68,0.1) 0%, transparent 50%);"></div>
        
        <!-- Grid Pattern -->
        <svg class="absolute inset-0 w-full h-full opacity-10 pointer-events-none">
          <defs>
            <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
              <path d="M 40 0 L 0 0 0 40" fill="none" stroke="white" stroke-width="0.5"/>
            </pattern>
          </defs>
          <rect width="100%" height="100%" fill="url(#grid)"/>
        </svg>
        
        <!-- Center Line -->
        <div class="absolute top-1/2 left-6 right-6 h-1 -translate-y-1/2 rounded-full"
             style="background: linear-gradient(90deg, transparent, rgba(255,255,255,0.15), transparent);"></div>
        
        <!-- Center Circle -->
        <div class="absolute top-1/2 left-1/2 w-16 h-16 -translate-x-1/2 -translate-y-1/2 rounded-full border-2 border-white/10"></div>
        
        <!-- Goal Zones -->
        <div class="absolute top-0 left-1/4 right-1/4 h-2 rounded-b-lg bg-gradient-to-b from-cyan-500/40 to-transparent"></div>
        <div class="absolute bottom-0 left-1/4 right-1/4 h-2 rounded-t-lg bg-gradient-to-t from-red-500/40 to-transparent"></div>

        <!-- Player Labels -->
        <div class="absolute top-2 left-1/2 -translate-x-1/2 text-cyan-500/60 text-xs font-bold tracking-widest">P1 ZONE</div>
        <div class="absolute bottom-2 left-1/2 -translate-x-1/2 text-red-500/60 text-xs font-bold tracking-widest">P2 ZONE</div>

        <!-- Paddle 1 (Top) -->
        <div id="paddle1" class="paddle paddle-p1 absolute rounded-full"
             style="width: 85px; height: 16px; top: 45px; left: 127px;">
          <div class="absolute top-1 left-3 right-3 h-1.5 bg-white/50 rounded-full"></div>
        </div>

        <!-- Paddle 2 (Bottom) -->
        <div id="paddle2" class="paddle paddle-p2 absolute rounded-full"
             style="width: 85px; height: 16px; bottom: 45px; left: 127px;">
          <div class="absolute top-1 left-3 right-3 h-1.5 bg-white/50 rounded-full"></div>
        </div>

        <!-- Ball 1 (Player 1) -->
        <div id="ball1" class="ball ball-p1 absolute rounded-full"
             style="width: 22px; height: 22px; top: 100px; left: 159px;"></div>

        <!-- Ball 2 (Player 2) -->
        <div id="ball2" class="ball ball-p2 absolute rounded-full"
             style="width: 22px; height: 22px; bottom: 100px; left: 159px;"></div>

        <!-- Obstacles Container -->
        <div id="obstacles"></div>

        <!-- Effects Container -->
        <div id="effects" class="pointer-events-none"></div>

        <!-- Menu Overlay -->
        <div id="menuOverlay" class="absolute inset-0 bg-black/95 flex flex-col items-center justify-center z-50">
          <div class="text-6xl mb-4" style="animation: float 2.5s ease-in-out infinite;">üèì</div>
          <h1 class="text-3xl font-black text-white mb-1 tracking-wider">PADDLE</h1>
          <h2 class="text-lg text-gray-500 mb-6 tracking-[0.3em]">ARENA</h2>
          
          <div class="bg-white/5 border border-white/10 rounded-xl px-6 py-4 mb-6">
            <p class="text-cyan-400 text-sm mb-3 flex items-center gap-3">
              <span class="text-2xl">üëÜ</span>
              <span>Drag on TOP half</span>
            </p>
            <p class="text-red-400 text-sm flex items-center gap-3">
              <span class="text-2xl">üëá</span>
              <span>Drag on BOTTOM half</span>
            </p>
          </div>
          
          <button id="startBtn" class="btn-3d bg-gradient-to-b from-green-500 to-green-600 text-white font-bold text-xl px-12 py-4 rounded-xl"
                  style="box-shadow: 0 5px 0 #15803d, 0 8px 25px rgba(34,197,94,0.4);">
            START GAME
          </button>
          
          <p class="text-gray-600 text-xs mt-4">Each player has 1 ball ‚Ä¢ Don't miss!</p>
        </div>

        <!-- Game Over Overlay -->
        <div id="gameOverOverlay" class="absolute inset-0 bg-black/95 flex flex-col items-center justify-center z-50 hidden">
          <div id="winnerEmoji" class="text-6xl mb-4">üèÜ</div>
          <h2 id="winnerText" class="text-2xl font-black mb-6" style="text-shadow: 0 0 30px currentColor;">PLAYER 1 WINS!</h2>
          
          <div class="flex gap-12 mb-8">
            <div class="text-center">
              <div class="w-16 h-16 rounded-full bg-gradient-to-b from-cyan-400 to-cyan-600 flex items-center justify-center text-2xl font-black text-white mb-2"
                   style="box-shadow: 0 4px 0 #0e7490;">
                <span id="finalScore1">0</span>
              </div>
              <span class="text-cyan-500 text-sm font-semibold">P1</span>
            </div>
            <div class="text-center">
              <div class="w-16 h-16 rounded-full bg-gradient-to-b from-red-400 to-red-600 flex items-center justify-center text-2xl font-black text-white mb-2"
                   style="box-shadow: 0 4px 0 #b91c1c;">
                <span id="finalScore2">0</span>
              </div>
              <span class="text-red-500 text-sm font-semibold">P2</span>
            </div>
          </div>
          
          <button id="restartBtn" class="btn-3d bg-gradient-to-b from-green-500 to-green-600 text-white font-bold text-xl px-12 py-4 rounded-xl"
                  style="box-shadow: 0 5px 0 #15803d, 0 8px 25px rgba(34,197,94,0.4);">
            PLAY AGAIN
          </button>
        </div>
      </div>

      <!-- Legend -->
      <div class="flex justify-center gap-6 mt-3 text-xs text-gray-500">
        <span class="flex items-center gap-2">
          <span class="w-4 h-2.5 rounded bg-gradient-to-b from-violet-400 to-violet-600" style="box-shadow: 0 2px 0 #5b21b6;"></span>
          Permanent
        </span>
        <span class="flex items-center gap-2">
          <span class="w-4 h-2.5 rounded bg-gradient-to-b from-pink-400 to-pink-600" style="box-shadow: 0 2px 0 #be123c;"></span>
          2 Hits to Break
        </span>
      </div>
    </div>
  </div>

  <script>
    // Game Constants
    const ARENA_WIDTH = 340;
    const ARENA_HEIGHT = 600;
    const PADDLE_WIDTH = 85;
    const PADDLE_HEIGHT = 16;
    const BALL_SIZE = 22;
    const BALL_RADIUS = BALL_SIZE / 2;
    const BALL_SPEED = 2.8;
    const PADDLE_MARGIN = 45;
    const PADDLE_HIT_SLOP = 18;

    // Game State
    let gameState = 'menu';
    let score = { p1: 0, p2: 0 };
    let paddle1X = (ARENA_WIDTH - PADDLE_WIDTH) / 2;
    let paddle2X = (ARENA_WIDTH - PADDLE_WIDTH) / 2;
    let ball1 = null;
    let ball2 = null;
    let obstacles = [];
    let lastTrailTime = 0;
    let lastFrameTime = null;

    // DOM Elements
    const arena = document.getElementById('arena');
    const paddle1El = document.getElementById('paddle1');
    const paddle2El = document.getElementById('paddle2');
    const ball1El = document.getElementById('ball1');
    const ball2El = document.getElementById('ball2');
    const obstaclesContainer = document.getElementById('obstacles');
    const effectsContainer = document.getElementById('effects');
    const menuOverlay = document.getElementById('menuOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const score1El = document.getElementById('score1');
    const score2El = document.getElementById('score2');
    const gameShell = document.getElementById('gameShell');

    let shellBase = null;

    function applyScale() {
      if (!gameShell) return;
      if (!shellBase) {
        shellBase = { w: gameShell.offsetWidth, h: gameShell.offsetHeight };
      }
      const padding = 16;
      const scaleW = (window.innerWidth - padding) / shellBase.w;
      const scaleH = (window.innerHeight - padding) / shellBase.h;
      let scale = Math.min(scaleW, scaleH);
      scale = Math.max(0.85, Math.min(scale, 1.6));
      gameShell.style.transform = `scale(${scale})`;
    }

    // Touch tracking
    let touches = {};

    // Initialize
    function init() {
      document.getElementById('startBtn').addEventListener('click', startGame);
      document.getElementById('restartBtn').addEventListener('click', startGame);
      applyScale();
      window.addEventListener('resize', applyScale);
      
      arena.addEventListener('touchstart', handleTouchStart, { passive: false });
      arena.addEventListener('touchmove', handleTouchMove, { passive: false });
      arena.addEventListener('touchend', handleTouchEnd, { passive: false });
      
      // Mouse support for testing
      arena.addEventListener('mousedown', handleMouseDown);
      arena.addEventListener('mousemove', handleMouseMove);
      arena.addEventListener('mouseup', handleMouseUp);
    }

    function startGame() {
      gameState = 'playing';
      score = { p1: 0, p2: 0 };
      updateScoreDisplay();
      lastFrameTime = null;
      lastTrailTime = 0;
      
      paddle1X = (ARENA_WIDTH - PADDLE_WIDTH) / 2;
      paddle2X = (ARENA_WIDTH - PADDLE_WIDTH) / 2;
      
      // Create balls
      ball1 = createBall(1);
      ball2 = createBall(2);
      
      // Create obstacles
      createObstacles();
      
      // Hide menus
      menuOverlay.classList.add('hidden');
      gameOverOverlay.classList.add('hidden');
      
      // Show balls
      ball1El.style.display = 'block';
      ball2El.style.display = 'block';
      
      // Start game loop
      requestAnimationFrame(gameLoop);
    }

    function createBall(player) {
      const dirX = Math.random() > 0.5 ? 1 : -1;
      const angle = (Math.PI / 6) + Math.random() * (Math.PI / 6);
      
      return {
        x: ARENA_WIDTH / 2,
        y: player === 1 ? 110 : ARENA_HEIGHT - 110,
        vx: Math.cos(angle) * BALL_SPEED * dirX,
        vy: player === 1 ? BALL_SPEED : -BALL_SPEED,
        active: true
      };
    }

    function createObstacles() {
      obstacles = [];
      obstaclesContainer.innerHTML = '';
      
      const centerY = ARENA_HEIGHT / 2;
      
      // 2 Permanent obstacles
      for (let i = 0; i < 2; i++) {
        const obs = {
          id: `perm-${i}`,
          x: i === 0 ? 40 + Math.random() * 60 : ARENA_WIDTH - 100 - Math.random() * 60,
          y: centerY - 15 + Math.random() * 30,
          width: 52,
          height: 20,
          permanent: true,
          hp: 999
        };
        obstacles.push(obs);
        createObstacleElement(obs);
      }
      
      // 4 Temporary obstacles
      for (let i = 0; i < 4; i++) {
        const obs = {
          id: `temp-${i}`,
          x: 50 + Math.random() * (ARENA_WIDTH - 110),
          y: centerY - 70 + Math.random() * 140,
          width: 44,
          height: 18,
          permanent: false,
          hp: 2
        };
        obstacles.push(obs);
        createObstacleElement(obs);
      }
    }

    function createObstacleElement(obs) {
      const el = document.createElement('div');
      el.id = obs.id;
      el.className = `obstacle absolute rounded-lg ${obs.permanent ? 'obstacle-permanent' : 'obstacle-temp'}`;
      el.style.cssText = `left: ${obs.x}px; top: ${obs.y}px; width: ${obs.width}px; height: ${obs.height}px;`;
      
      if (obs.permanent) {
        el.innerHTML = '<div class="absolute top-1 left-2 right-2 h-1 bg-white/40 rounded-full"></div>';
      }
      
      obstaclesContainer.appendChild(el);
    }

    function isPointOnPaddle(player, x, y) {
      const paddleX = player === 1 ? paddle1X : paddle2X;
      const paddleTop = player === 1 ? PADDLE_MARGIN : (ARENA_HEIGHT - PADDLE_MARGIN - PADDLE_HEIGHT);
      const paddleBottom = paddleTop + PADDLE_HEIGHT;
      return (
        x >= paddleX - PADDLE_HIT_SLOP &&
        x <= paddleX + PADDLE_WIDTH + PADDLE_HIT_SLOP &&
        y >= paddleTop - PADDLE_HIT_SLOP &&
        y <= paddleBottom + PADDLE_HIT_SLOP
      );
    }

    function updatePaddleFromTouch(touchData) {
      const grabOffset = typeof touchData.grabOffset === 'number' ? touchData.grabOffset : (PADDLE_WIDTH / 2);
      const targetX = Math.max(0, Math.min(ARENA_WIDTH - PADDLE_WIDTH, touchData.x - grabOffset));
      
      if (touchData.player === 1) {
        paddle1X = targetX;
      } else {
        paddle2X = targetX;
      }
    }

    // Touch Handlers
    function handleTouchStart(e) {
      if (gameState !== 'playing') return;
      e.preventDefault();
      
      for (let touch of e.changedTouches) {
        const rect = arena.getBoundingClientRect();
        const rawX = touch.clientX - rect.left;
        const rawY = touch.clientY - rect.top;
        const x = rawX * (ARENA_WIDTH / rect.width);
        const y = rawY * (ARENA_HEIGHT / rect.height);
        const player = y < ARENA_HEIGHT / 2 ? 1 : 2;
        if (!isPointOnPaddle(player, x, y)) continue;

        const paddleX = player === 1 ? paddle1X : paddle2X;
        touches[touch.identifier] = {
          player,
          x,
          grabOffset: x - paddleX
        };
      }
    }

    function handleTouchMove(e) {
      if (gameState !== 'playing') return;
      e.preventDefault();
      
      for (let touch of e.changedTouches) {
        if (touches[touch.identifier]) {
          const rect = arena.getBoundingClientRect();
          const rawX = touch.clientX - rect.left;
          const x = rawX * (ARENA_WIDTH / rect.width);
          touches[touch.identifier].x = x;
          updatePaddleFromTouch(touches[touch.identifier]);
        }
      }
    }

    function handleTouchEnd(e) {
      for (let touch of e.changedTouches) {
        delete touches[touch.identifier];
      }
    }

    // Mouse handlers (for desktop testing)
    let mouseDown = false;
    let mousePlayer = 0;
    let mouseGrabOffset = 0;

    function handleMouseDown(e) {
      if (gameState !== 'playing') return;
      const rect = arena.getBoundingClientRect();
      const rawY = e.clientY - rect.top;
      const rawX = e.clientX - rect.left;
      const x = rawX * (ARENA_WIDTH / rect.width);
      const y = rawY * (ARENA_HEIGHT / rect.height);
      mousePlayer = y < ARENA_HEIGHT / 2 ? 1 : 2;
      if (!isPointOnPaddle(mousePlayer, x, y)) return;
      mouseDown = true;
      const paddleX = mousePlayer === 1 ? paddle1X : paddle2X;
      mouseGrabOffset = x - paddleX;
      handleMouseMove(e);
    }

    function handleMouseMove(e) {
      if (!mouseDown || gameState !== 'playing') return;
      const rect = arena.getBoundingClientRect();
      const rawX = e.clientX - rect.left;
      const x = rawX * (ARENA_WIDTH / rect.width);
      const targetX = Math.max(0, Math.min(ARENA_WIDTH - PADDLE_WIDTH, x - mouseGrabOffset));
      
      if (mousePlayer === 1) {
        paddle1X = targetX;
      } else {
        paddle2X = targetX;
      }
    }

    function handleMouseUp() {
      mouseDown = false;
    }

    // Effects
    function createTrail(x, y, isPlayer1) {
      const trail = document.createElement('div');
      trail.className = 'ball-trail';
      trail.style.cssText = `
        left: ${x - 8}px; 
        top: ${y - 8}px; 
        width: 16px; 
        height: 16px;
        background: ${isPlayer1 ? 'rgba(14, 165, 233, 0.5)' : 'rgba(239, 68, 68, 0.5)'};
        box-shadow: 0 0 10px ${isPlayer1 ? 'rgba(14, 165, 233, 0.8)' : 'rgba(239, 68, 68, 0.8)'};
      `;
      effectsContainer.appendChild(trail);
      setTimeout(() => trail.remove(), 300);
    }

    function createHitEffect(x, y, color) {
      // Ring effect
      const ring = document.createElement('div');
      ring.className = 'hit-effect';
      ring.style.cssText = `
        left: ${x}px; 
        top: ${y}px; 
        width: 30px; 
        height: 30px;
        border: 3px solid ${color};
        box-shadow: 0 0 20px ${color};
      `;
      effectsContainer.appendChild(ring);
      setTimeout(() => ring.remove(), 400);
      
      // Sparks
      for (let i = 0; i < 8; i++) {
        const spark = document.createElement('div');
        spark.className = 'spark';
        const angle = (Math.PI * 2 / 8) * i;
        const dist = 25 + Math.random() * 20;
        const endX = x + Math.cos(angle) * dist;
        const endY = y + Math.sin(angle) * dist;
        
        spark.style.cssText = `
          left: ${x}px; 
          top: ${y}px; 
          background: ${color};
          box-shadow: 0 0 6px ${color};
        `;
        spark.animate([
          { left: `${x}px`, top: `${y}px`, opacity: 1 },
          { left: `${endX}px`, top: `${endY}px`, opacity: 0 }
        ], { duration: 400, easing: 'ease-out' });
        
        effectsContainer.appendChild(spark);
        setTimeout(() => spark.remove(), 400);
      }
    }

    // Update functions
    function updateBall(ball, ballEl, isPlayer1, dt) {
      if (!ball || !ball.active) return ball;

      let { x, y, vx, vy } = ball;
      
      x += vx * dt;
      y += vy * dt;

      // Wall collisions
      if (x <= BALL_RADIUS) {
        vx = Math.abs(vx);
        x = BALL_RADIUS;
        createHitEffect(x, y, '#ffffff');
      }
      if (x >= ARENA_WIDTH - BALL_RADIUS) {
        vx = -Math.abs(vx);
        x = ARENA_WIDTH - BALL_RADIUS;
        createHitEffect(x, y, '#ffffff');
      }

      // Paddle 1 collision (top)
      const p1Top = PADDLE_MARGIN;
      const p1Bottom = PADDLE_MARGIN + PADDLE_HEIGHT;
      if (vy < 0 && y - BALL_RADIUS <= p1Bottom && y > p1Top) {
        if (x >= paddle1X - 5 && x <= paddle1X + PADDLE_WIDTH + 5) {
          const hitPos = (x - paddle1X) / PADDLE_WIDTH - 0.5;
          vx = hitPos * BALL_SPEED * 2;
          vy = Math.abs(vy);
          y = p1Bottom + BALL_RADIUS;
          createHitEffect(x, p1Bottom, '#0ea5e9');
        }
      }

      // Paddle 2 collision (bottom)
      const p2Top = ARENA_HEIGHT - PADDLE_MARGIN - PADDLE_HEIGHT;
      const p2Bottom = ARENA_HEIGHT - PADDLE_MARGIN;
      if (vy > 0 && y + BALL_RADIUS >= p2Top && y < p2Bottom) {
        if (x >= paddle2X - 5 && x <= paddle2X + PADDLE_WIDTH + 5) {
          const hitPos = (x - paddle2X) / PADDLE_WIDTH - 0.5;
          vx = hitPos * BALL_SPEED * 2;
          vy = -Math.abs(vy);
          y = p2Top - BALL_RADIUS;
          createHitEffect(x, p2Top, '#ef4444');
        }
      }

      // Obstacle collisions
      for (let i = 0; i < obstacles.length; i++) {
        const obs = obstacles[i];
        if (obs.hp <= 0) continue;
        
        if (x + BALL_RADIUS > obs.x && x - BALL_RADIUS < obs.x + obs.width &&
            y + BALL_RADIUS > obs.y && y - BALL_RADIUS < obs.y + obs.height) {
          
          const overlapL = (x + BALL_RADIUS) - obs.x;
          const overlapR = (obs.x + obs.width) - (x - BALL_RADIUS);
          const overlapT = (y + BALL_RADIUS) - obs.y;
          const overlapB = (obs.y + obs.height) - (y - BALL_RADIUS);
          
          if (Math.min(overlapL, overlapR) < Math.min(overlapT, overlapB)) {
            vx = -vx;
          } else {
            vy = -vy;
          }
          
          const obsEl = document.getElementById(obs.id);
          if (obsEl) {
            obsEl.classList.add('obstacle-hit');
            setTimeout(() => obsEl.classList.remove('obstacle-hit'), 150);
          }
          
          createHitEffect(x, y, obs.permanent ? '#8b5cf6' : '#fb7185');
          
          if (!obs.permanent) {
            obs.hp--;
            if (obs.hp <= 0) {
              if (obsEl) obsEl.style.display = 'none';
            } else {
              if (obsEl) obsEl.style.opacity = '0.5';
            }
          }
          break;
        }
      }

      // Normalize speed
      const speed = Math.sqrt(vx * vx + vy * vy);
      if (speed > 0.5) {
        vx = (vx / speed) * BALL_SPEED;
        vy = (vy / speed) * BALL_SPEED;
      }

      // Out of bounds
      if (y < -20) {
        score.p2++;
        updateScoreDisplay();
        createHitEffect(x, 20, '#ef4444');
        ballEl.style.display = 'none';
        return { ...ball, active: false };
      }
      if (y > ARENA_HEIGHT + 20) {
        score.p1++;
        updateScoreDisplay();
        createHitEffect(x, ARENA_HEIGHT - 20, '#0ea5e9');
        ballEl.style.display = 'none';
        return { ...ball, active: false };
      }

      // Update position
      ballEl.style.left = (x - BALL_RADIUS) + 'px';
      ballEl.style.top = (y - BALL_RADIUS) + 'px';

      return { x, y, vx, vy, active: true };
    }

    function updateScoreDisplay() {
      score1El.textContent = score.p1;
      score2El.textContent = score.p2;
      score1El.classList.add('score-pop');
      score2El.classList.add('score-pop');
      setTimeout(() => {
        score1El.classList.remove('score-pop');
        score2El.classList.remove('score-pop');
      }, 300);
    }

    function checkGameOver() {
      if (!ball1.active && !ball2.active) {
        endGame('draw');
      } else if (!ball1.active) {
        endGame('p2');
      } else if (!ball2.active) {
        endGame('p1');
      }
    }

    function endGame(winner) {
      gameState = 'gameover';
      
      const winnerText = document.getElementById('winnerText');
      const winnerEmoji = document.getElementById('winnerEmoji');
      
      if (winner === 'draw') {
        winnerText.textContent = "IT'S A DRAW!";
        winnerText.style.color = '#ffffff';
        winnerEmoji.textContent = 'ü§ù';
      } else if (winner === 'p1') {
        winnerText.textContent = 'PLAYER 1 WINS!';
        winnerText.style.color = '#22d3ee';
        winnerEmoji.textContent = 'üèÜ';
      } else {
        winnerText.textContent = 'PLAYER 2 WINS!';
        winnerText.style.color = '#f87171';
        winnerEmoji.textContent = 'üèÜ';
      }
      
      document.getElementById('finalScore1').textContent = score.p1;
      document.getElementById('finalScore2').textContent = score.p2;
      
      gameOverOverlay.classList.remove('hidden');
    }

    // Game Loop
    function gameLoop(timestamp) {
      if (gameState !== 'playing') return;
      if (lastFrameTime === null) lastFrameTime = timestamp;
      const deltaMs = timestamp - lastFrameTime;
      lastFrameTime = timestamp;
      const dt = Math.min(2.5, deltaMs / 16.6667);

      // Update paddles
      paddle1El.style.left = paddle1X + 'px';
      paddle2El.style.left = paddle2X + 'px';

      // Update balls
      if (ball1.active) {
        ball1 = updateBall(ball1, ball1El, true, dt);
        if (timestamp - lastTrailTime > 30) {
          createTrail(ball1.x, ball1.y, true);
          lastTrailTime = timestamp;
        }
      }
      
      if (ball2.active) {
        ball2 = updateBall(ball2, ball2El, false, dt);
        if (timestamp - lastTrailTime > 30) {
          createTrail(ball2.x, ball2.y, false);
          lastTrailTime = timestamp;
        }
      }

      // Check game over
      if (!ball1.active || !ball2.active) {
        setTimeout(() => {
          if (gameState === 'playing') checkGameOver();
        }, 500);
      }

      if (ball1.active || ball2.active) {
        requestAnimationFrame(gameLoop);
      }
    }

    // Start
    init();
  </script>
</body>
</html>
